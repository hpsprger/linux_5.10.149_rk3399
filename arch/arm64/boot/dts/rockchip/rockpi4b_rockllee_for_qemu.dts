/dts-v1/;

/* 
拉起内核的时候，uboot打印了下面的信息
=> booti  0x13800000    0x2c800000:0x1f400000     0x12E00000
## Flattened Device Tree blob at 12e00000
   Booting using the fdt blob at 0x12e00000
   reserving fdt memory region: addr=529c1000 size=1000
   reserving fdt memory region: addr=529c5000 size=1f400000
   Loading Ramdisk to 335c1000, end 529c1000 ... OK
   Loading Device Tree to 00000000335bd000, end 00000000335c0f0c ... OK
Adding bank: 0x00200000 - 0x80000000 (size: 0x7fe00000)
Total: 14097.576 ms
*/
/* 设置保留内存用，因为之前uboot中在dtb中设置了保留内存，所以这里才添加的，目前我自己暂时不用 */
/* 所以下面的保留内存其实是给fdt预留的，如上的打印信息  */
/* /memreserve/	0x00000000529c1000 0x0000000000001000;  */
/* /memreserve/	0x00000000529c5000 0x000000001f400000;  */

/ {
	/* interrupt-parent  = <&xx>; &xx就是取值某一个节点，指定上一级中断控制器 */
	interrupt-parent = <&gic>; /* 各个有 interrupts 描述信息的节点，可以通过这里的描述来找到对应的父节点中断控制器，从而知道自己解析中断的相关的配置信息，比如interrupt-cells */
	#size-cells = <0x02>;
	#address-cells = <0x02>;
	compatible = "linux,dummy-virt";
	
	/* uboot重新修改或创建了/memory node，uboot 会根据内存的尺寸来填充内容 ==> fdt_fixup_memory_banks ==> 8.96: uboot中修改dtb内容 */
	/* 为了方便调试，将uboot中的调整屏蔽掉，直接用dtb这里来控制 */
	memory@5EA00000 {
		/* reg = <0x00 0x5EA00000 0x00 0x40000000>; */  /* booti  0x13800000【kernel】    0x2c800000:0x1f400000【ramdisk】     0x12E00000【dtb】 */
		/* reg = <0x00 0x200000 0x00 0x7FE00000>;   */  /* qemu中实现的系统内存空间是 0x0--0x80000000,所以注意这里不要超过范围了，物理地址不能超过 0x80000000，否则有可能内核初始化就崩溃了，分配到的物理地址CPU不能访问的 */
		/* reg = <0x00 0x4BD00000 0x00 0x34300000>;  ==> 【没有覆盖 ramdisk img】报错 initrd not fully accessible via the linear mapping -- please check your bootloader */
		/* reg = <0x00 0x2c800000 0x00 0x53800000>;  ==> 【没有覆盖 kernel  img】报错 Unable to handle kernel paging request at virtual address ffffff801520bff8 */
		/* reg = <0x00 0x13800000 0x00 0x6C800000>;  ==> 【没有覆盖 dtb     img】可以运行起来 */
		/*                                        */   
		/*	# cat /proc/iomem                     */
		/*	13800000-7fffffff : System RAM        */
		/*	  13800000-149bffff : Kernel code     */
		/*	  149c0000-14f2ffff : reserved        */
		/*	  14f30000-1529ffff : Kernel data     */
		/*			device_type = "memory";       */
		reg = <0x00 0x200000 0x00 0x7FE00000>;    /* kernnel memblock等模块 就是从这个地方拿到可以管理的物理内存的起始地址与大小的 */
		device_type = "memory";
	};

/*
	bootargs = "root=/dev/ram0  ramdisk_size=14745600  nokaslr  console=ttyAMA0 earlycon=pl011,0xf6ff0000 loglevel=8 rw ";
	stdout-path = "/pl011@0xf6ff0000"; ==> 其实 console=ttyAMA0 是因为串口注册失败了导致earlycon(pl011)没有被卸载，导致后面串口输出还是通过pl011
*/
/*
	pl011@f6ff0000 {
		clock-names = "uartclk\0apb_pclk";
		clocks = <&apbpclk &apbpclk>;
		interrupts = <0x00 0x01 0x04>;
		reg = <0x00 0xf6ff0000 0x00 0x1000>;
		compatible = "arm,pl011\0arm,primecell";
	};
*/

/* virtio,mmio 其实是挂在pcie总线上的一个pcie设备  ==> virtio device  ==> 没有这个节点 网卡也是能正常工作了，所以与这个节点无关 */
/*	virtio_mmio@ffc10000 {                                                   */
/*		dma-coherent;                                                        */
/*		interrupts = <0x00 0x3 0x01>;                                        */
/*		reg = <0x00 0xffc10000 0x00 0x200>;                                  */
/*		compatible = "virtio,mmio";                                          */
/*	};                                                                       */
/*                                                                           */

	/* pcie host 控制器设备节点 ==> pcie控制器驱动会去扫描pcie总线 ==> 扫描出挂在pcie总线上的所有的pcie设备 ==> pcie设备扫描出后挂到对应的总线上，然后再加载对应的pcie设备驱动，再pcie设备执行probe处理 */
	/* 请参考<<【阅1-done】【DeviceTree】devicetree-specification-v0.4-rc1.pdf>>  2.4.4这节 */
	/* 从逻辑上分析PCIE控制器应该是要同时支持多种中断方式，毕竟机制本身也不冲突，而且PCIE控制器肯定是要挂各种不同的设备（msi msix intx），*/
	/* 所以必须同时要能支持多种中断机制才能满足挂不同设备的场景， ==> 其实从DTS中就可以看出来，*/
	/* DTS中INTX MSI-X这两种中断机制在DTS 的中断控制器节点里面都有出现的！！！！*/
	/* 但是从PCIE设备的角度分析,PCIE设备应该就只会实现一种中断机制就好了  */
	pcie@10000000 {
		#size-cells = <0x02>;
		#interrupt-cells = <0x01>; /* 指示interrupt-map中用1个值来表示地址 */
		#address-cells = <0x03>;   /* 指示interrupt-map中用3个值来表示中断 */
		device_type = "pci";
		compatible = "pci-host-ecam-generic";
		interrupt-map-mask = <0x00ffff00 0x00 0x00 0x07>; /* 与 interrupt-map 每个entry的前4个值相与，得到值后再查表 */
		interrupt-map = <
	  /* 参考qemu 中创建设备节点的地方的注释 create_pcie_irq_map */
	  /* 
			uint32_t map[] = {
                devfn << 8, 0, 0,                                   ==> devfn   
                pin + 1,                                            ==> PCI pin 
                gic_phandle, 0, 0, irq_type, irq_nr, irq_level };   ==> GIC irq 
				                                              为什么这里要多加两个零？？？
		==>  devfn << 8,  0,     0,     pin + 1,    gic_phandle,       0,   0,     irq_type,   irq_nr,    irq_level
		        0x00     0x00   0x00      0x01         0x8005         0x00 0x00      0x00       0x04         0x04
	  */
	  /* The encoding includes the bus number (0x0 << 16), device number (0x11 << 11), and function number(0x0 << 8). */
	  /* 看代码 of_irq_parse_pci ==> 这个函数中是用下面的方式来组织地址格式的              */
	  /*           laddr[0] = cpu_to_be32((pdev->bus->number << 16) | (pdev->devfn << 8)); ==>  __be32 laddr[3] ==> 地址是3个字节 ==> laddr[0] = (bus_num<<16) | (devfn<<8)  */
	  /*           laddr[1] = laddr[2] = cpu_to_be32(0);                                   ==>  __be32 laddr[3] ==> 地址是3个字节 ==> laddr[1] & laddr[2] 都是0              */
	  /* 每个slot(对应一个pcie设备, BDF) 4个中断 inta intb intc intd*/
	  /* 下面这个表，对于使用INTX 的中断来说，很重要，决定了对应的PCIE设备的INTX硬件(pin) 对应CPU的哪个物理中断(line) ==> 我挂载pcie总线上的SDCHI-PCI设备就是因为用的是INTX中断，且物理中断号是0，导致中断注册失败了 */
	  /*  00:01.0 ==> VIRTIO-NET设备 0x00000800 */
	  /*  00:02.0 ==> SDHCI-PCI设备  0x00001000 */
	  /*  下面编写BDF的信息，按 of_irq_parse_pci 这个函数中组织的方式来编写 */
	  /*  virtio-net设备的 Bus:0  devfn:0x8  */
	  /*  SDHCI-PCIE设备的 Bus:0  devfn:0x10 */
	  /*  nterrupt-map-mask = <0x00000000 0x00 0x00 0x07>;  ==> ！！！！注意要配合掩码一起使用 */   
	  /*  (pdev->bus->number << 16) | (pdev->devfn << 8) */
	  /*  SPI:0x00 ==> 基数值为32  ==>  所以SPI的0x4号中断的物理中断号就是 0x36 ==>  不过 virtio-net用的是msi-x中断，就没有用INTX中断了 */
	  /*  SPI:0x00 ==> 基数值为32  ==>  所以SPI的0x5号中断的物理中断号就是 0x37 ==>  18:  0   0   0   0   GICv3  37 Level     mmc0 */
	  /*  PCEI控制器肯定是可以同时支持INTX MSI MSIX 中断机制的，毕竟要挂各种的硬件设备，但是PCIE设备一般就只实现一种中断机制就好了      */
	  /*  下面的中断映射，不能乱填哈，必须与实际的中断硬件设计连线匹配，比如 SDHCI-PCIE设备 用的是INTA引脚 ==> lspci 看 Interrupt: pin A routed to IRQ xxx  */
	  /*                                                               所以SDHCI-PCIE设备的中断 是用的是PCIE控制器的INTA中断，QEMU中PCIE控制器的INTA中断 连接的是 36号物理中断 */
	  /*                                                               所以SDHCI-PCIE设备的中断 对应的CPU的物理中断号也应该是36才对，下面应该填4才对(之前填的是5，导致SDHCI-PCIE设备的中断上不来)          */
	  /* (bus<<16)|(devfn<<8)   固定为0   固定为0  PCI的中断引脚号    父节点    这是啥？(必须的，补充对齐？)  映射的物理中断类型    映射的物理中断号   映射的物理中断触发类型*/
/*                                                             */
/* PCI-to-PCI bridge specification                             */
/* 9.1: Interrupt routing. Table 9-1                           */
/*                                                             */
/* the PCI Express Base Specification, Revision 2.1            */
/* 2.2.8.1: INTx interrutp signaling - Rules                   */
/*          the Implementation Note                            */
/*          Table 2-20                                         */
/* 0 <= pin <= 3    0 = INTA, 1 = INTB, 2 = INTC, 3 = INTD     */
/* 0-origin unlike PCI interrupt pin register.                 */
/*                                                             */
/* int pci_swizzle_map_irq_fn(PCIDevice *pci_dev, int pin)     */
/* 特别注意: INTX中断，PCIE设备的INTX中断 最终怎么映射连接到 PCIE控制器的哪一个INTX硬件(准备说是PCIE设备的INTX中断映射到PCIE控制器的哪一个INTX中断) */
/* 取决于上面说的这个表，为了实现中断的负载均衡，这个是qemu中的实现，具体的单板上具体怎么映射要看具体的控制器采用什么规范，如果是物理连线的话，则取决于单板的连线了 */
/* 中断在解析DTS得到一个物理中断号后还是扫不出设备，内核日志中一直打印cmd interrupt超时，这里的原因是 qemu 中用到的PCIE控制器会对PCIE设备的INTX中断进行 中断负载均衡，*/
/* 发现是PCIE设备的inta中断，被PCIE控制器 负载均衡 映射到PCIE控制器的intc中断了，导致上报给CPU的是另外一个物理中断(原先中断上不来时配置的是36号中断，后来发现正确的是38号物理中断)，所以之前一直收不到中断 */
			/* pcie控制器的 4个INTX中断 INTA# INTB# INTC# INTD#  的 映射 */
	        0x00000000           0x00      0x00         0x01            &gic           0x00  0x00                  0x00                 0x04                 0x04 																								        
	        0x00000000           0x00      0x00         0x02            &gic           0x00  0x00                  0x00                 0x05                 0x04 																								        
	        0x00000000           0x00      0x00         0x03            &gic           0x00  0x00                  0x00                 0x06                 0x04 																								        
	        0x00000000           0x00      0x00         0x04            &gic           0x00  0x00                  0x00                 0x07                 0x04 																								        

			/* 一个slot 可以配置使用4个INTX中断 INTA# INTB# INTC# INTD#  ==> INTX中断为低电平触发 ==> 中断先给到PCIE控制器 */
	        0x00000800           0x00      0x00         0x01            &gic           0x00  0x00                  0x00                 0x05                 0x04 																								        
	        0x00000800           0x00      0x00         0x02            &gic           0x00  0x00                  0x00                 0x06                 0x04 																								        
	        0x00000800           0x00      0x00         0x03            &gic           0x00  0x00                  0x00                 0x07                 0x04 																								        
	        0x00000800           0x00      0x00         0x04            &gic           0x00  0x00                  0x00                 0x08                 0x04 																								        

			/* 一个slot 可以配置使用4个INTX中断 INTA# INTB# INTC# INTD#  ==> INTX中断为低电平触发 ==> 中断先给到PCIE控制器 */
	        0x00001000           0x00      0x00         0x01            &gic           0x00  0x00                  0x00                 0x06                 0x04
	        0x00001000           0x00      0x00         0x02            &gic           0x00  0x00                  0x00                 0x07                 0x04
	        0x00001000           0x00      0x00         0x03            &gic           0x00  0x00                  0x00                 0x04                 0x04
	        0x00001000           0x00      0x00         0x04            &gic           0x00  0x00                  0x00                 0x05                 0x04>;

		/* ranges 表示 地址空间的映射 */
		/*
		   最终第一行说明的意思就是：片选0，偏移0（选中了网卡），被映射到CPU地址空间的0x10100000~0x10110000中，地址长度为0x10000。
		   理解下来，可以认为ranges的格式为<子节点address 父节点address 子节点size>, 而address长度由对应cells决定
		   ranges属性为一个地址转换表。表中的每一行都包含了子地址、父地址、在各自地址空间内的区域大小。他们的大小（包含的cell）分别由子节点的address-cells的值、父节点的address-cells的值和子节点的size-cells来决定
		   
		   像之前描述过的本地总线一样，PCI地址空间与CPU地址空间是完全分离的，所以这里需要通过定义ranges属性进行地址转化。
		   #address-cells定义PCI使用3个cell，并且PCI的地址范围通过两个单位就可以解读。所以，首先的问题就是，为什么需要用3个32位的cell来描述一个PCI地址。
		  
		   像之前描述过的本地总线一样，PCI地址空间与CPU地址空间是完全分离的，所以这里需要通过定义ranges属性进行地址转化。
		   #address-cells定义PCI使用3个cell，并且PCI的地址范围通过两个单位就可以解读。所以，首先的问题就是，为什么需要用3个32位的cell来描述一个PCI地址。
		   这三个cell分别代表物理地址高位、中位、低位：
		   1 phys.high cell : npt000ss bbbbbbbb dddddfff rrrrrrrr
		   2 phys.mid cell : hhhhhhh hhhhhhhh hhhhhhhh hhhhhhh
		   3 phys.low cell : llllllll llllllll llllllll llllllll
		   PCI地址为64位宽度，编码在phys.mid和phys.low中。
		   真正重要的东西在于phys.high这一位空间中：
		   n：代表重申请空间标志（这里没有使用）
		   p：代表预读空间（缓存）标志
		   t：别名地址标志（这里没有使用）
		   ss：空间代码
		   	00：配置空间
		   	01：IO空间
		   	10：32位存储空间
		   	11：64位存储空间
		   bbbbbbbb： PCI总线号。PCI有可能是层次性架构，所以我们可能需要区分一些子-总线
		   ddddd：设备号，通常由初始化设备选择信号IDSEL连接时申请。
		   fff：功能序号，有些多功能PCI设备可能用到。
		   rrrrrrrr：注册号，在设置周期使用
		*/
		/* ranges = <0x83000000 0x0 0xfa000000 0x0 0xfa000000 0x0 0x1e00000>;
			     ==> 0x83000000 表示一些PCIE地址空间的属性， 
				     0x0 0xfa000000表示PCIE地址， 
					 0x0 0xfa000000表示CPU地址空间(物理地址)，
					 0x0 0x1e00000长度
				 ==> 父节点address-cells为1，子节点address-cells为3， 子节点size-cells为2
		*/
		/* pcie地址空间 与 CPU地址空间 之间的映射 ==> address translation ==> Region 0, Region 1 -- 32 */
		/* 为各个pcie设备配置pcie地址时 ==> 可以使用 cpu_pa == pcie_bus_addr 的方式 */
		/* ranges表示资源配置信息，7个元素为一组，第一个元素表示属性，第二个和第三个为pci域地址，第四个和第五个为CPU域地址空间 */
		/*                                        第六个和第七个为size，表示设备将访问CPU域的地址时，将转化到pci域的地址 */
		/*    ranges的一个entry ==> phys.high(pcie空间属性)   phys.mid(pcie_addr)   phys.low(pcie_addr)     CPU物理地址(2Byte)     地址空间长度(2Byte)  */
		/*==> !!!!!!!!!!!!!!!!!!!!!!!!! 通过在DTS中PCIE的这个设备节点，来定义cpu_addr  与 pcie_addr 的地址映射关系  */
		/*==> !!!!!!!!!!!!!!!!!!!!!!!!! 这个映射关系也就相当于pcie控制器的各个region0-32, ATU一样，指定了地址转换关系了，非常重要  */
		/*==> 下面: 0x83000000 表示一些PCIE地址空间的属性， 0x0 0xfa000000表示PCIE地址， 0x0 0xfa000000表示CPU地址空间，0x0 0x1e00000长度 */
		/*==> 比如RK3399，我们知道，他有32个region,每个regison 对应一组寄存器， */
		/*    这组寄存器里面 就是 用来描述 CPU_ADDR --> PCIE_ADDR的映射关系的，也就是你访问CPU地址空间的XXX物理地址， */
		/*    PCIE控制器 就会通过 这个region寄存器里面的信息 来将这这个XXX物理地址 转换为 对应的PCIE 地址， */
		/*    在PCIE总线上传输出去并访问到目的空间，那么这个映射关系，软件怎么来感知配置呢？？ */
		/*    就是通过DTS的PCIE设备节点的ranges属性来做到了，如下  */
		/*==> 最后可以在linux上，可以通过 cat /proc/iomem 来看到这个节点对应的各个CPU的物理地址空间范围的 */
		/*==> 第九课:设备树  MEM&IO的区别  配置ATUPCIe_Host驱动分析之地址映射    RK3399_PCIe_Host驱动分析_地址映射 */
		/* phys.high(pcie空间属性) ==> 0x01000000 ==> io空间       */
		/* phys.high(pcie空间属性) ==> 0x02000000 ==> 32位存储空间 */
		/* phys.high(pcie空间属性) ==> 0x03000000 ==> 64位存储空间 */
		/* CPU地址空间已经在QEMU中各个模块都已经配置好了，所以一般将PCIE地址与CPU物理地址配置成一样的就好了 */
		/* 血泪的教训: 这里ranges映射的时候 一定要一一映射，也就是pcie_addr 要等于 CPU addr，否则PCIE设备无法上报中断，导致网口不通，改为一一映射后就通了，可能是驱动写的不好，才有这个限制 */
		ranges = <0x01000000        0x00000000       0xbeff0000         0x00000000 0xbeff0000         0x00000000 0x00010000    /* [RK3399_PCIE_PIO]  = { 0xbeff0000, 0x00010000 【64K】}, */
				  0x02000000        0x00000000       0x90000000         0x00000000 0x90000000         0x00000000 0x2eff0000    /* [RK3399_PCIE_MMIO] = { 0x90000000, 0x2eff0000【751MB】 }, */
				  0x03000000        0x00000080       0x00000000         0x00000080 0x00000000         0x00000080 0x00000000>;  /* [RK3399_HIGH_PCIE_MMIO]  = { 0x3eff0000, 0x800x00000000【512GB】 }, */
		reg = <0x40 0x10000000 0x00 0x10000000>; /*  0x4010000000&256MB ==> RK3399_HIGH_PCIE_ECAM */

		/* MSI控制器配置，分配msi-specifier数据 */
		/* &its 这个标签是在 节点interrupt-controller@fee00000 中定义的 */
		/* 后面仔细看下
	    /* 参考 <<第十五课:MSI_MSI-X中断之源码分析>>
		/*     在gic的节点中，有一个its子节点
		/*     its节点对应的驱动程序 在 irq-gic-its.c  这里面它去创建了一个irq_domain域，通过irq_domain_add_tree 
		/*     PCIE控制器本身，也是用的这个设备树，只不过它根据这个设备树节点its又 创建了另外一个域
		/*  
		/*     1:在PCIE控制器的设备树里面，有一项 msi-map， 从这里开始分析，PCIE控制器识别到一个设备后，这个设备有 总线号  设备号 功能号【BDF】，
		/* 		这三个数值会构造出一个数值 叫做 request ID, 我们用  request ID 来表示这个设备，
		/* 		这个设备会对应 会对应到上面的MSI中断，比如对应到 图中 域2 中的 哪个中断呢？ 又对应到 域1 中的哪个中断呢？ 
		/* 		又对应到 域4 中的哪个中断呢？
		/* 		有个映射关系，msi-map = <0x0  &its  0x0  0x1000>;  
		/* 		第一个0x0表示RID，如果RID 等于0的话就 对应 &its 这个控制器的第0号中断（第三个值0x），如果RID 等于1的话就 对应 &its 这个控制器的第1号中断，RID 就是 request ID, 
		/*     2:也就是根据 msi-map， 将RID传入  msi-map，得到一个数值，如图，0对0，1对1，
		/* 		这个数值仍然叫RID，也就是 这个设备将会去使用 这个 its 这个中断控制器里面的 这个RID中断，这个中断用RID来标记，
		/*   msi-map 是用来把PCIe设备映射到MSI控制器，它的格式为
		/* msi-map = <rid-base &msi-controller msi-base length>; */
		/*            rid-base：第1个Request ID，就是使用<bus, dev, function>组成的一个数字 */
		/*            msi-controller：这个PCIe设备映射到哪个MSI控制器 */
		/*            msi-base：第1个PCIe设备映射到MSI控制器哪个中断 */
		/*            length：能映射多少个设备 */
		msi-map = <0x0 &its 0x0 0x1000>;
		dma-coherent; /* dma一致性 */
		bus-range = <0x00 0xff>; /* bus-range一般指的是该设备(一般为RC)下的pci总线号范围 */
		linux,pci-domain = <0x00>;
	};

	uart2:serial@ff1a0000 {
		compatible = "rockchip,rk3399-uart", "snps,dw-apb-uart";
		reg = <0x0 0xff1a0000 0x0 0x100>;
		clocks = <&apbpclk &apbpclk>;
		clock-names = "baudclk", "apb_pclk";
		/* interrupts = <0x00 100 4>; */
		/* 2 + 32 = 34 ==> spi中断 offset为2，32为SPI的偏移基值 ==> 物理中断号为34，因为qemu中 uart8250的 output pin 是连接到 GIC 的 2号input gpio 引脚上去了
		/* 因为外部模块连接到GIC的几号引脚input gpio上, gic 报给 CPU的物理中断号 就是这个gpio的index值 */
		interrupts = <0x00 2 0x04>; 
		reg-shift = <0x02>;
		reg-io-width = <0x04>;
		status = "okay";
	};

	/* irq_domain 以及 中断相关的处理流程，请参考:<<12-virq--hwirq--irqdomain--中断处理转换注册处理流程【非常好】.emmx>> */
	gic:intc@fee00000 {
		reg = <0x00 0xfee00000 0x00 0x10000>, /* GICD */
		      <0x00 0xfef00000 0x00 0xc0000>, /* GICR */
		      <0x00 0xfff00000 0x00 0x10000>, /* GICC */
		      <0x00 0xfff10000 0x00 0x10000>, /* GICH */
		      <0x00 0xfff20000 0x00 0x10000>; /* GICV */
		compatible = "arm,gic-v3";
		ranges;
		#size-cells = <0x02>;
		#address-cells = <0x02>;
		interrupt-controller;
		#interrupt-cells = <0x03>;
		/* 参考 ==> 12-PCIE---INTX---MSI---MSI-X机制研究.emmx */
		/* ITS的基地址就是下面reg属性中的 0xfee20000 ， devmem2 是一个可以读任意物理地址的工具 */
		/* 在gic的节点中，有一个its子节点 */
		/* its节点对应的驱动程序 在 irq-gic-its.c  这里面它去创建了一个irq_domain域，通过irq_domain_add_tree  */
		/* PCIE控制器本身，也是用的这个设备树，只不过它根据这个设备树节点its又 创建了另外一个域 */
		its: interrupt-controller@fff30000 {
			compatible = "arm,gic-v3-its";
			/* msi-controller:表示节点是MSI控制器 */
			/* msi-controller:表示是一个MSI（Message Signaled Interrupt）控制器节点，这里需要注意的是，有的SoC中断控制器使用的是GICv2版本，而GICv2并不支持MSI，所以会导致该功能的缺失 */
			msi-controller;
			#msi-cells = <1>;
			/* ITS的基地址是 下面的前两个数值，后面的是空间的长度 */
			/* 怎么发出MSI/MSI-X中断?? ==> PCIe设备向发出中断，它发出TLP包，往某个地址写入某个数据即可 */
			/* 上面说的某个地址指的就是 ==>  ITS节点里面的这个reg 指定的基地址了 ==> 往哪个地址？GICv3 ITS的GITS_TRANSLATER寄存器，TLP包里使用的是PCI地址 */
			/* 写什么数据？0、1、2、……，要发出第1个中断时写0，要发出第2个中断时写1，…… */
			/* 也就是往下面的地址空间写数据就会触发 MSI-X中断 */
			/* 下面的地址是自己规划的，比如qemu中，我用的是内存空间是[RK3399_GIC_ITS] = { 0xfff30000,   RK3399_128K},  */
			/* gic-v3设备节点中的子设备节点ITS（Interrupt Translation Services）：一个GIC中有1到多个ITS设备，ITS设备用于将消息信号中断(MSI)路由到cpu，ITS设备节点的描述如下：*/
			/* compatible：必须包含字符串"arm,gic-v3-its"，表示这是一个ITS设备 */
			/* msi-controller：标识该设备节点为MSI控制器 */
			/* #msi-cells：必须是1，这里面是MSI设备的DeviceID */
			/* reg：ITS寄存器的物理基地址 */
			/* https://blog.csdn.net/wyy4045/article/details/104827111 */ 
			/*  主控芯片中有一个GICV3的中断控制器，我们的设备想要发出基于消息的中断  只要 去 写 这个中断控制器中的 GITS_TRANSLATER寄存器 就可以了 */
			/* 这个寄存器是位于 主控芯片中的 中断控制器中的，它的地址是CPU地址，我们的PCIE设备 需要得到 这个 寄存器的CPU地址 对应的PCIE地址       */
			/* PCIE控制器会去识别出这些PCIE设备，并把这个 前面说的这个CPU地址( GITS_TRANSLATER寄存器的地址)转换为PCIE地址 写给这些设备 */
	     	/* 对于 使用MSI中断的PCIE设备 ==> 这些地址是写在配置空间里面的 */
	     	/* 对于 使用MSI-X中断的PCIE设备 ==> 它会从配置空间里面来找  我的那些中断向量信息 保存在哪一个内存空间的哪个位置上（Table BAR + Table Offset），==> 配置空间的 Vector table: BAR=1 offset=00000000 */
			/*                                  根据这两个信息在 PCIE设备的内存中找到自己的中断向量表的位置，中断向量表的每一行就对应一个中断， */
			/*                                  我们需要把 GITS_TRANSLATER寄存器 对应的PCIE地址 写到这个 向量表的每一个ENTRY中去，当PCIE设备想发出MSI-X中断的时候， */
			/*									它会把DWORD2中的数据 写入到 DWORD1+DWORD0 指向的 空间中（也就是 GITS_TRANSLATER寄存器）来产生MSI-X中断， */			
			/* 正常情况下，用MSIX中断， PCIE设备 触发中断的中断向量表的每个entry 中 都有存放  GICV3 的  GITS_TRANSLATER寄存器的PCIE地址，我去检查下 对应的内存中的数据看看 */
			reg = <0x0 0xfff30000 0x0 0x20000>; /* ==> 0xfff30000 就是 GICV3 的 ITS模块的寄存器空间了，这个空间里面包含有 GITS_TRANSLATER寄存器，GicV3 ITS组件【qdev_new(itsclass)】相关的寄存器空间 [RK3399_GIC_ITS]  =  { 0xfff30000,   RK3399_128K}, */
		};                                      /* 如果是这样的话, PCIE设备的触发中断的向量表中 每个entry ==> DWORD1+DWORD0 就是 GITS_TRANSLATER寄存器 对应的PCIE地址 */
	};                                          /* 这样的话，如果有几个中断，那么应该就会有几个ENTRY 有这个PCIE地址值，虽然我们可能不知道这个GITS_TRANSLATER寄存器的PCIE地址，但我们可以用这个特点来鉴别向量表是否正常 */

	timer {
		interrupts = <0x01 13 0xf04>, /* ARCH_TIMER_PHYS_SECURE_PPI ==> #interrupt-cells = <0x03> ==> !!! 0x10 is offset just !!! ==> 13为十进制 ==> hwirq = 13 + 16 = 29 */
					 <0x01 14 0xf04>, /* ARCH_TIMER_PHYS_NONSECURE_PPI */
					 <0x01 11 0xf04>, /* ARCH_TIMER_VIRT_PPI */
					 <0x01 10 0xf04>; /* ARCH_TIMER_HYP_PPI  */
		always-on;
		compatible = "arm,armv8-timer\0arm,armv7-timer";
	};

	watchdog@ff848000 {
		compatible = "snps,dw-wdt";
		reg = <0x00 0xff848000 0x00 0x100>;
		clocks = <&apbpclk &apbpclk>;
		interrupts = <0x00 0x2D 0x04>;
	};

/* PSCI ==> Power State Coordination Interface  */
/* 实现了el2 或 el3的芯片或qemu模拟系统中， 通过hvc or smc + functionid 去通知el2 el3 以及tee atf 进行配置多核协同环境的  */
/* 很简单的一个道理， 比如实现使能了tee ree atf hypervisor的系统下  */
/* 你开启或关闭一个CPU core就必须通知到各个子系统（tee hypervisor ree atf ）, 各个子系统为这个新核的启动或关闭做好适配工作才行 */
	psci {
		migrate = <0xc4000005>; /* PSCI function id  ==> 函数 psci_cpu_on */
		cpu_on = <0xc4000003>;  /* PSCI function id  ==> 函数 psci_cpu_on */
		cpu_off = <0x84000002>; /* PSCI function id  ==> 函数 psci_cpu_on */
		cpu_suspend = <0xc4000001>; /* PSCI function id  ==> 函数 psci_cpu_on */
		method = "hvc";  /* EL1 PSCI 的系统调用的方式，可以选择HVC 或 SMC ==> __arm_smccc_hvc or __arm_smccc_smc ==> 根据SOC的实现定义 目前qemu中可以实现这两张模式的仿真 */
		compatible = "arm,psci-1.0\0arm,psci-0.2\0arm,psci";
	};

	fw-cfg@6004000 {
		dma-coherent;
		reg = <0x00 0x6004000 0x00 0x18>;
		compatible = "qemu,fw-cfg-mmio";
	};

	cpus {
		#size-cells = <0x00>;
		#address-cells = <0x01>;

		cpu-map {

			socket0 {

				cluster0 {

					core0 {
						cpu = <0x8004>;
					};

					core1 {
						cpu = <0x8003>;
					};

					core2 {
						cpu = <0x8002>;
					};

					core3 {
						cpu = <0x8001>;
					};
				};
			};
		};

		cpu@0 {
			phandle = <0x8004>;
			reg = <0x00>;
			enable-method = "psci"; /* CPU拉起的方式 */
			compatible = "arm,cortex-a57";
			device_type = "cpu";
		};

		cpu@1 {
			phandle = <0x8003>;
			reg = <0x01>;
			enable-method = "psci";
			compatible = "arm,cortex-a57";
			device_type = "cpu";
		};

		cpu@2 {
			phandle = <0x8002>;
			reg = <0x02>;
			enable-method = "psci";
			compatible = "arm,cortex-a57";
			device_type = "cpu";
		};

		cpu@3 {
			phandle = <0x8001>;
			reg = <0x03>;
			enable-method = "psci";
			compatible = "arm,cortex-a57";
			device_type = "cpu";
		};
	};

	apbpclk:apb-pclk {
		phandle = <0x8000>;
		clock-output-names = "clk24mhz";
		clock-frequency = <0x16e3600>;
		#clock-cells = <0x00>;
		compatible = "fixed-clock";
	};

	chosen {
		/* dts 中用这两个参数来指定ramdisk 的 起始与结束地址 ==> 内核会扫描DTB获取这两个参数后，内核才知道initrd的起始与结束位置的，否则内核会加载ramdisk失败 */
		/* uboot重定位了ramdisk后，就是通过在dts中新加linux,initrd-start linux,initrd-end 的方式来告知内核的 */
		/* 下面两个参数是必须的 ==> 15-文件系统挂载过程【ramdisk等】.emmx ==> early_init_dt_check_for_initrd 内核会扫描DTB获取这两个参数后，内核才知道initrd的起始与结束位置的，否则内核会加载ramdisk失败 ，之前不用加是因为uboot自动帮我们加好了，现在把uboot的调整去掉了，所以就要自己加上了，内核才能正常加载initrd */
		/* 所以只要有下面的参数，其实通过 booti  0x13800000   -  0x12E00000 这个命令行也能正常启动内核与加载文件系统，正常运行的 */
		/* 事实证明:内核挂载的时候，内核加载 ramdisk 时，内核是通过ramdisk 镜像的实际大小来知道ramdisk的大小的，不通过 bootargs 的   ramdisk_size 这个参数来设置的 */
		linux,initrd-end = <0x3C200000>;
		linux,initrd-start = <0x2c800000>;
		/* bootargs = "root=/dev/ram0  ramdisk_size=14745600  nokaslr  console=ttyAMA0 earlycon=pl011,0xf6ff0000 loglevel=8 rw "; */
		/* roclpi4b 上用的是 console=ttyS2 ==> 因为他确实有多个串口，而且用的就是第2个串口； 而qemu上只模拟了一个串口，所以需要用 ttyS0 */
		/* 内核加载 ramdisk 时，内核是通过ramdisk 镜像的实际大小来知道ramdisk的大小的，不通过 bootargs 的   ramdisk_size 这个参数来设置的, 所以下面的 ramdisk_size设置为任意值都没有关系 */
		bootargs = "root=/dev/ram0  ramdisk_size=0xC800000  nokaslr earlycon=pl011,0xf6ff0000  console=ttyS0,1500000n8 loglevel=8 rw ";
		/* stdout-path = "/pl011@0xf6ff0000"; */
		/* stdout-path = "uart2:1500000n8"; */ /* 屏蔽了这句话后串口还是正常的，目前看 */ /* 猜测是不是存在多个串口的时候用这个参数来指定从哪一个串口输出？？？没有验证过 */
		kaslr-seed = <0x00 0x00>; 
	};
};