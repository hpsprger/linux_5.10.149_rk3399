/dts-v1/;

/ {
	/* interrupt-parent  = <&xx>; &xx就是取值某一个节点，指定上一级中断控制器 */
	interrupt-parent = <&gic>; /* 各个有 interrupts 描述信息的节点，可以通过这里的描述来找到对应的父节点中断控制器，从而知道自己解析中断的相关的配置信息，比如interrupt-cells */
	#size-cells = <0x02>;
	#address-cells = <0x02>;
	compatible = "linux,dummy-virt";
	
	/* uboot重新修改或创建了/memory node，uboot 会根据内存的尺寸来填充内容 ==> fdt_fixup_memory_banks ==> 8.96: uboot中修改dtb内容 */
	/* 为了方便调试，将uboot中的调整屏蔽掉，直接用dtb这里来控制 */
	memory@5EA00000 {
		/* reg = <0x00 0x5EA00000 0x00 0x40000000>; */
		reg = <0x00 0x5EA00000 0x00 0x20000000>;
		device_type = "memory";
	};

/*
	bootargs = "root=/dev/ram0  ramdisk_size=14745600  nokaslr  console=ttyAMA0 earlycon=pl011,0xf6ff0000 loglevel=8 rw ";
	stdout-path = "/pl011@0xf6ff0000"; ==> 其实 console=ttyAMA0 是因为串口注册失败了导致earlycon(pl011)没有被卸载，导致后面串口输出还是通过pl011
*/
/*
	pl011@f6ff0000 {
		clock-names = "uartclk\0apb_pclk";
		clocks = <&apbpclk &apbpclk>;
		interrupts = <0x00 0x01 0x04>;
		reg = <0x00 0xf6ff0000 0x00 0x1000>;
		compatible = "arm,pl011\0arm,primecell";
	};
*/

	/* virtio,mmio 其实是挂在pcie总线上的一个pcie设备 */
	virtio_mmio@ffc10000 {
		dma-coherent;
		interrupts = <0x00 0x3 0x01>;
		reg = <0x00 0xffc10000 0x00 0x200>;
		compatible = "virtio,mmio";
	};

	/* pcie host 控制器设备节点 ==> pcie控制器驱动会去扫描pcie总线 ==> 扫描出挂在pcie总线上的所有的pcie设备 ==> pcie设备扫描出后挂到对应的总线上，然后再加载对应的pcie设备驱动，再pcie设备执行probe处理 */
	/* 请参考<<【阅1-done】【DeviceTree】devicetree-specification-v0.4-rc1.pdf>>  2.4.4这节 */
	pcie@10000000 {
		interrupt-map-mask = <0x1800 0x00 0x00 0x07>; /* 与 interrupt-map 每个entry的前4个值相与，得到值后再查表 */
		interrupt-map = <
	  /* 参考qemu 中创建设备节点的地方的注释 create_pcie_irq_map */
	  /* 
			uint32_t map[] = {
                devfn << 8, 0, 0,                                   ==> devfn   
                pin + 1,                                            ==> PCI pin 
                gic_phandle, 0, 0, irq_type, irq_nr, irq_level };   ==> GIC irq 
	  */
	  /* bus device   fn  PCI的中断引脚号  父节点(0x8005==>intc@8000000)                 父节点对应的中断类型      父节点的物理中断号  父节点的物理中断触发类型*/
	  /* 每个slot(对应一个pcie设备, BDF) 4个中断 inta intb intc intd*/
		0x00  0x00   0x00      0x01            0x8005                          0x00 0x00       0x00                      0x04                0x04 
		0x00  0x00   0x00      0x02            0x8005                          0x00 0x00       0x00                      0x05                0x04 
		0x00  0x00   0x00      0x03            0x8005                          0x00 0x00       0x00                      0x06                0x04 
		0x00  0x00   0x00      0x04            0x8005                          0x00 0x00       0x00                      0x07                0x04 
		
	   0x800  0x00   0x00      0x01            0x8005                          0x00 0x00       0x00                      0x04                0x04 
	   0x800  0x00   0x00      0x02            0x8005                          0x00 0x00       0x00                      0x05                0x04 
	   0x800  0x00   0x00      0x03            0x8005                          0x00 0x00       0x00                      0x06                0x04 
	   0x800  0x00   0x00      0x04            0x8005                          0x00 0x00       0x00                      0x07                0x04 
	   
	  0x1000  0x00   0x00      0x01            0x8005                          0x00 0x00       0x00                      0x04                0x04 
	  0x1000  0x00   0x00      0x02            0x8005                          0x00 0x00       0x00                      0x05                0x04 
	  0x1000  0x00   0x00      0x03            0x8005                          0x00 0x00       0x00                      0x06                0x04 
	  0x1000  0x00   0x00      0x04            0x8005                          0x00 0x00       0x00                      0x07                0x04 

	  0x1800  0x00   0x00      0x01            0x8005                          0x00 0x00       0x00                      0x04                0x04 
	  0x1800  0x00   0x00      0x02            0x8005                          0x00 0x00       0x00                      0x05                0x04 
	  0x1800  0x00   0x00      0x03            0x8005                          0x00 0x00       0x00                      0x06                0x04 
	  0x1800  0x00   0x00      0x04            0x8005                          0x00 0x00       0x00                      0x07                0x04>;
		/* ranges 表示 地址空间的映射 */
		/*
		   最终第一行说明的意思就是：片选0，偏移0（选中了网卡），被映射到CPU地址空间的0x10100000~0x10110000中，地址长度为0x10000。
		   理解下来，可以认为ranges的格式为<子节点address 父节点address 子节点size>, 而address长度由对应cells决定
		   ranges属性为一个地址转换表。表中的每一行都包含了子地址、父地址、在各自地址空间内的区域大小。他们的大小（包含的cell）分别由子节点的address-cells的值、父节点的address-cells的值和子节点的size-cells来决定
		   
		   像之前描述过的本地总线一样，PCI地址空间与CPU地址空间是完全分离的，所以这里需要通过定义ranges属性进行地址转化。
		   #address-cells定义PCI使用3个cell，并且PCI的地址范围通过两个单位就可以解读。所以，首先的问题就是，为什么需要用3个32位的cell来描述一个PCI地址。
		  
		   像之前描述过的本地总线一样，PCI地址空间与CPU地址空间是完全分离的，所以这里需要通过定义ranges属性进行地址转化。
		   #address-cells定义PCI使用3个cell，并且PCI的地址范围通过两个单位就可以解读。所以，首先的问题就是，为什么需要用3个32位的cell来描述一个PCI地址。
		   这三个cell分别代表物理地址高位、中位、低位：
		   1 phys.high cell : npt000ss bbbbbbbb dddddfff rrrrrrrr
		   2 phys.mid cell : hhhhhhh hhhhhhhh hhhhhhhh hhhhhhh
		   3 phys.low cell : llllllll llllllll llllllll llllllll
		   PCI地址为64位宽度，编码在phys.mid和phys.low中。
		   真正重要的东西在于phys.high这一位空间中：
		   n：代表重申请空间标志（这里没有使用）
		   p：代表预读空间（缓存）标志
		   t：别名地址标志（这里没有使用）
		   ss：空间代码
		   	00：设置空间
		   	01：IO空间
		   	10：32位存储空间
		   	11：64位存储空间
		   bbbbbbbb： PCI总线号。PCI有可能是层次性架构，所以我们可能需要区分一些子-总线
		   ddddd：设备号，通常由初始化设备选择信号IDSEL连接时申请。
		   fff：功能序号，有些多功能PCI设备可能用到。
		   rrrrrrrr：注册号，在设置周期使用
		*/
		/* ranges = <0x83000000 0x0 0xfa000000 0x0 0xfa000000 0x0 0x1e00000>;
			     ==> 0x83000000 表示一些PCIE地址空间的属性， 
				     0x0 0xfa000000表示PCIE地址， 
					 0x0 0xfa000000表示CPU地址空间(物理地址)，
					 0x0 0x1e00000长度
				 ==> 父节点address-cells为1，子节点address-cells为3， 子节点size-cells为2
		*/
		/* pcie地址空间 与 CPU地址空间 之间的映射 ==> address translation ==> Region 0, Region 1 -- 32 */
		/* 为各个pcie设备配置pcie地址时 ==> 可以使用 cpu_pa == pcie_bus_addr 的方式 */
		/*        phys.high(pcie)   phys.mid(pcie)   phys.low(pcie)     CPU物理地址(2Byte)            地址空间长度(2Byte)  */
		ranges = <0x01000000        0x00000000       0x00000000         0x00000000 0xbeff0000         0x00000000 0x00010000    /* [RK3399_PCIE_PIO]  = { 0xbeff0000, 0x00010000 【64K】}, */
				  0x02000000        0x00000000       0x10000000         0x00000000 0x90000000         0x00000000 0x2eff0000    /* [RK3399_PCIE_MMIO] = { 0x90000000, 0x2eff0000【751MB】 }, */
				  0x03000000        0x00000080       0x00000000         0x00000080 0x00000000         0x00000080 0x00000000>;  /* [RK3399_HIGH_PCIE_MMIO]  = { 0x3eff0000, 0x800x00000000【512GB】 }, */
		reg = <0x40 0x10000000 0x00 0x10000000>; /*  0x4010000000&256MB ==> RK3399_HIGH_PCIE_ECAM */

		/* MSI控制器配置，分配msi-specifier数据 */
		/* &its 这个标签是在 节点interrupt-controller@fee00000 中定义的 */
		/* 后面仔细看下
	    /* 参考 <<第十五课:MSI_MSI-X中断之源码分析>>
		/*     在gic的节点中，有一个its子节点
		/*     its节点对应的驱动程序 在 irq-gic-its.c  这里面它去创建了一个irq_domain域，通过irq_domain_add_tree 
		/*     PCIE控制器本身，也是用的这个设备树，只不过它根据这个设备树节点its又 创建了另外一个域
		/*  
		/*     1:在PCIE控制器的设备树里面，有一项 msi-map， 从这里开始分析，PCIE控制器识别到一个设备后，这个设备有 总线号  设备号 功能号【BDF】，
		/* 		这三个数值会构造出一个数值 叫做 request ID, 我们用  request ID 来表示这个设备，
		/* 		这个设备会对应 会对应到上面的MSI中断，比如对应到 图中 域2 中的 哪个中断呢？ 又对应到 域1 中的哪个中断呢？ 
		/* 		又对应到 域4 中的哪个中断呢？
		/* 		有个映射关系，msi-map = <0x0  &its  0x0  0x1000>;  
		/* 		第一个0x0表示RID，如果RID 等于0的话就 对应 &its 这个控制器的第0号中断（第三个值0x），如果RID 等于1的话就 对应 &its 这个控制器的第1号中断，RID 就是 request ID, 
		/*     2:也就是根据 msi-map， 将RID传入  msi-map，得到一个数值，如图，0对0，1对1，
		/* 		这个数值仍然叫RID，也就是 这个设备将会去使用 这个 its 这个中断控制器里面的 这个RID中断，这个中断用RID来标记，
		/*   msi-map 是用来把PCIe设备映射到MSI控制器，它的格式为
		/* msi-map = <rid-base &msi-controller msi-base length>; */
		/*            rid-base：第1个Request ID，就是使用<bus, dev, function>组成的一个数字 */
		/*            msi-controller：这个PCIe设备映射到哪个MSI控制器 */
		/*            msi-base：第1个PCIe设备映射到MSI控制器哪个中断 */
		/*            length：能映射多少个设备 */
		msi-map = <0x0 &its 0x0 0x1000>;
		dma-coherent; /* dma一致性 */
		bus-range = <0x00 0xff>; /* bus-range一般指的是该设备(一般为RC)下的pci总线号范围 */
		linux,pci-domain = <0x00>;
		#size-cells = <0x02>;
		#interrupt-cells = <0x01>; /* 指示interrupt-map中用1个值来表示地址 */
		#address-cells = <0x03>;   /* 指示interrupt-map中用3个值来表示中断 */
		device_type = "pci";
		compatible = "pci-host-ecam-generic";
	};

	uart2:serial@ff1a0000 {
		compatible = "rockchip,rk3399-uart", "snps,dw-apb-uart";
		reg = <0x0 0xff1a0000 0x0 0x100>;
		clocks = <&apbpclk &apbpclk>;
		clock-names = "baudclk", "apb_pclk";
		/* interrupts = <0x00 100 4>; */
		/* 2 + 32 = 34 ==> spi中断 offset为2，32为SPI的偏移基值 ==> 物理中断号为34，因为qemu中 uart8250的 output pin 是连接到 GIC 的 2号input gpio 引脚上去了
		/* 因为外部模块连接到GIC的几号引脚input gpio上, gic 报给 CPU的物理中断号 就是这个gpio的index值 */
		interrupts = <0x00 2 0x04>; 
		reg-shift = <0x02>;
		reg-io-width = <0x04>;
		status = "okay";
	};

	/* irq_domain 以及 中断相关的处理流程，请参考:<<12-virq--hwirq--irqdomain--中断处理转换注册处理流程【非常好】.emmx>> */
	gic:intc@fee00000 {
		reg = <0x00 0xfee00000 0x00 0x10000>, /* GICD */
		      <0x00 0xfef00000 0x00 0xc0000>, /* GICR */
		      <0x00 0xfff00000 0x00 0x10000>, /* GICC */
		      <0x00 0xfff10000 0x00 0x10000>, /* GICH */
		      <0x00 0xfff20000 0x00 0x10000>; /* GICV */
		compatible = "arm,gic-v3";
		ranges;
		#size-cells = <0x02>;
		#address-cells = <0x02>;
		interrupt-controller;
		#interrupt-cells = <0x03>;
		/* 参考 ==> 12-PCIE---INTX---MSI---MSI-X机制研究.emmx */
		/* ITS的基地址就是下面reg属性中的 0xfee20000 ， devmem2 是一个可以读任意物理地址的工具 */
		/* 在gic的节点中，有一个its子节点 */
		/* its节点对应的驱动程序 在 irq-gic-its.c  这里面它去创建了一个irq_domain域，通过irq_domain_add_tree  */
		/* PCIE控制器本身，也是用的这个设备树，只不过它根据这个设备树节点its又 创建了另外一个域 */
		its: interrupt-controller@fee20000 {
			compatible = "arm,gic-v3-its";
			/* msi-controller:表示节点是MSI控制器 */
			/* msi-controller:表示是一个MSI（Message Signaled Interrupt）控制器节点，这里需要注意的是，有的SoC中断控制器使用的是GICv2版本，而GICv2并不支持MSI，所以会导致该功能的缺失 */
			msi-controller;
			#msi-cells = <1>;
			/* ITS的基地址是 下面的前两个数值，后面的是空间的长度 */
			/* 怎么发出MSI/MSI-X中断?? ==> PCIe设备向发出中断，它发出TLP包，往某个地址写入某个数据即可 */
			/* 上面说的某个地址指的就是 ==>  ITS节点里面的这个reg 指定的基地址了 ==> 往哪个地址？GICv3 ITS的GITS_TRANSLATER寄存器，TLP包里使用的是PCI地址 */
			/* 写什么数据？0、1、2、……，要发出第1个中断时写0，要发出第2个中断时写1，…… */
			/* 也就是往下面的地址空间写数据就会触发 MSI-X中断 */
			/* 下面的地址是自己规划的，比如qemu中，我用的是内存空间是[RK3399_GIC_ITS] = { 0xfff30000,   RK3399_128K},  */
			reg = <0x0 0xfff30000 0x0 0x20000>;
		};
	};

	timer {
		interrupts = <0x01 13 0xf04>, /* ARCH_TIMER_PHYS_SECURE_PPI ==> #interrupt-cells = <0x03> ==> !!! 0x10 is offset just !!! ==> 13为十进制 ==> hwirq = 13 + 16 = 29 */
					 <0x01 14 0xf04>, /* ARCH_TIMER_PHYS_NONSECURE_PPI */
					 <0x01 11 0xf04>, /* ARCH_TIMER_VIRT_PPI */
					 <0x01 10 0xf04>; /* ARCH_TIMER_HYP_PPI  */
		always-on;
		compatible = "arm,armv8-timer\0arm,armv7-timer";
	};

	psci {
		migrate = <0xc4000005>;
		cpu_on = <0xc4000003>;
		cpu_off = <0x84000002>;
		cpu_suspend = <0xc4000001>;
		method = "hvc";
		compatible = "arm,psci-1.0\0arm,psci-0.2\0arm,psci";
	};

	fw-cfg@6004000 {
		dma-coherent;
		reg = <0x00 0x6004000 0x00 0x18>;
		compatible = "qemu,fw-cfg-mmio";
	};

	cpus {
		#size-cells = <0x00>;
		#address-cells = <0x01>;

		cpu-map {

			socket0 {

				cluster0 {

					core0 {
						cpu = <0x8004>;
					};

					core1 {
						cpu = <0x8003>;
					};

					core2 {
						cpu = <0x8002>;
					};

					core3 {
						cpu = <0x8001>;
					};
				};
			};
		};

		cpu@0 {
			phandle = <0x8004>;
			reg = <0x00>;
			enable-method = "psci";
			compatible = "arm,cortex-a57";
			device_type = "cpu";
		};

		cpu@1 {
			phandle = <0x8003>;
			reg = <0x01>;
			enable-method = "psci";
			compatible = "arm,cortex-a57";
			device_type = "cpu";
		};

		cpu@2 {
			phandle = <0x8002>;
			reg = <0x02>;
			enable-method = "psci";
			compatible = "arm,cortex-a57";
			device_type = "cpu";
		};

		cpu@3 {
			phandle = <0x8001>;
			reg = <0x03>;
			enable-method = "psci";
			compatible = "arm,cortex-a57";
			device_type = "cpu";
		};
	};

	apbpclk:apb-pclk {
		phandle = <0x8000>;
		clock-output-names = "clk24mhz";
		clock-frequency = <0x16e3600>;
		#clock-cells = <0x00>;
		compatible = "fixed-clock";
	};

	chosen {
		linux,initrd-end = <0x67400000>;
		linux,initrd-start = <0x48000000>;
		/* bootargs = "root=/dev/ram0  ramdisk_size=14745600  nokaslr  console=ttyAMA0 earlycon=pl011,0xf6ff0000 loglevel=8 rw "; */
		/* roclpi4b 上用的是 console=ttyS2 ==> 因为他确实有多个串口，而且用的就是第2个串口； 而qemu上只模拟了一个串口，所以需要用 ttyS0 */
		bootargs = "root=/dev/ram0  ramdisk_size=14745600  nokaslr earlycon=pl011,0xf6ff0000  console=ttyS0,1500000n8 loglevel=8 rw ";
		/* stdout-path = "/pl011@0xf6ff0000"; */
		/* stdout-path = "uart2:1500000n8"; */ /* 屏蔽了这句话后串口还是正常的，目前看 */
		kaslr-seed = <0x00 0x00>;
	};
};